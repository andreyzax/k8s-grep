#!/usr/bin/env python3

import sys
import os
import shlex

try:
    import yaml
except ModuleNotFoundError:
    print("Error - Python YAML package is not installed, execute 'python -m pip install pyyaml' to install it and try again.")
    sys.exit(1)

from argparse import ArgumentParser
from subprocess import Popen, PIPE, TimeoutExpired
from os import walk as tree_walk


def eprint(*args):
    ''' Wraper around print() that prints to stderr '''
    return print(*args, file=sys.stderr)

def stream_objects_from_cmd(command):
    ''' Generator function that returns a stream of k8s objects from the output of a command'''
    try:
        process = Popen(shlex.split(command), stdout=PIPE, stderr=PIPE ,universal_newlines=True)

        k8s_objects = yaml.safe_load_all(process.stdout)
        for k8s_object in k8s_objects:
            yield k8s_object

        process.wait(timeout=10)
    except TimeoutExpired as e:
        eprint(f"{command} stuck after {e.timeout}.\n {e.cmd} stderr: {e.stderr}\n\n killing {e.cmd} and exiting")
        process.kill()
        sys.exit(1)
    except OSError as e:
        eprint(f"Error executing {command}: {e.strerror}\n\n exiting.")
        sys.exit(1)




def stream_objects_from_dir(path, suffix='.yaml'):
    ''' Merges the yaml objects of all files in a directory tree that end with`suffix` into
        a single generator object '''

    def _handle_errors(e):
        raise e

    try:
        for dir_path, _, file_names in tree_walk(path, onerror=_handle_errors, followlinks=True):
            filterd_files = [f for f in file_names if f.endswith(suffix)]

            for file_name in filterd_files:
                with open(os.path.join(dir_path, file_name), mode='r', encoding='utf-8') as f:
                    k8s_objects = yaml.safe_load_all(f)

                    for k8s_object in k8s_objects:
                        yield k8s_object
    except OSError as e:
        eprint(f"Error scanning directory tree: {e.strerror}")
        if hasattr(e, 'filename'):
            eprint(f"File: {e.filename}")
        eprint('Exiting.')
        sys.exit(1)



parser = ArgumentParser(usage='%(prog)s [options]')
parser.add_argument("dir_path", action="store", default=None, nargs="?",
                    help="directory path to filter")
parser.add_argument("-ks", "--kustomize", action="store_true", dest="kustomize",
                    help="Use kustomize to render the manifests before filtering")
name_matcher = parser.add_mutually_exclusive_group()
name_matcher.add_argument("-n","--name", action="append", dest="name", default=None,
                    help="filter by name - can be passed multiple times")
name_matcher.add_argument("-xn", "--exclude-name", action="append", dest="xname", default=None,
                    help="exclude by name - can be passed multiple times")
kind_matcher = parser.add_mutually_exclusive_group()
kind_matcher.add_argument("-k", "--kind", action="append", dest="kind", default=None,
                    help="filter by kind - can be passed multiple times")
kind_matcher.add_argument("-xk", "--exclude-kind", action="append", dest="xkind", default=None,
                    help="exclude by kind - can be passed multiple times")
args = parser.parse_args()

if args.dir_path is None and not sys.stdin.isatty():
    k8s_objects = yaml.safe_load_all(sys.stdin)
elif args.kustomize:
    k8s_objects = stream_objects_from_cmd(f'kustomize build --enable-alpha-plugins --load-restrictor LoadRestrictionsNone {args.dir_path}') #TODO: make kustomize args configurable
else:
    k8s_objects = stream_objects_from_dir(args.dir_path)


matches = []
for obj in k8s_objects:
    if not ('kind' in obj and 'metadata' in obj and 'name' in obj['metadata']):
        print(f'Error in object {0}\nCould not find kind or metadata.name field!')
        sys.exit(1)
    if args.kind is not None \
        and not any(k for k in args.kind if k.lower() == obj['kind'].lower()):
            continue
    if args.xkind is not None \
        and any(k for k in args.xkind if k.lower() == obj['kind'].lower()):
            continue

    if args.name is not None \
        and not any(k for k in args.name if k.lower() == obj['metadata']['name'].lower()):
            continue
    if args.xname is not None \
        and any(k for k in args.xname if k.lower() == obj['metadata']['name'].lower()):
            continue
    matches.append(obj)

print(yaml.safe_dump_all(matches))
